!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!C  PROGRAMA PARA GENERAR ARCHIVO DE ENTRADA PARA EL PROGRAMA DE ELEMENTOS    C
!C                   FINITOS DESARROLLADO POR JUAN CARLOS.                    C
!C                                                                            C
!C EL PROGRAMA SE ALIMENTA POR EL ARCHIVO *.msh GENERADO POR EL PROGRAMA GMSH C
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!C
!C
PROGRAM MALLAS
!
!
USE OMP_LIB
IMPLICIT NONE
!
!
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!    DECLARACIÓN DE VARIABLES
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
!
!VARIABLES GENERALES.
INTEGER I, J, K, L, M, N, O, P, Q, F
INTEGER II, JJ, NIMPRIME, IFLAG, IPOS
INTEGER NP, ND, NEL, NMAT, PROBLEM
INTEGER NGF, NGLXY, NGLX, NGLY
INTEGER NX, NY, NLF, NTC, TONDA
INTEGER NG  !NÚMERO DE PUNTOS DE GAUSS.
INTEGER PARA    !PARA SABER SI SE IMPRIME O NO INFORMACIÓN PARA EL PARAVIEW.
INTEGER CONTA1, CONTA2, CONTA3, CONTA4, CONTA5, CONTA6
INTEGER NP1
REAL*8 JUAN
REAL*8 NUHS, BETAHS, RHOHS                  !PROPIEDADES DEL HALF-SPACE
REAL*8, ALLOCATABLE, DIMENSION(:):: X, Y    !COORDINATES POINTS.
INTEGER, ALLOCATABLE, DIMENSION(:):: IDN    !LABEL POINTS.
INTEGER, ALLOCATABLE, DIMENSION(:):: TP     !ELEMENT TYPE 2: TRIANGLE, 3: CUADRILATERAL
INTEGER, ALLOCATABLE, DIMENSION(:):: TPB    !AUXILIAR
INTEGER, ALLOCATABLE, DIMENSION(:):: TLRX   !NÚMERO DE LINEAS CON RESTRICCIONES EN X.
INTEGER, ALLOCATABLE, DIMENSION(:):: TLRY   !NÚMERO DE LINEAS CON RESTRICCIONES EN Y.
INTEGER, ALLOCATABLE, DIMENSION(:):: TLF    !NÚMERO DE LINEAS CARGADAS.
INTEGER, ALLOCATABLE, DIMENSION(:):: NODEIZ, NODEDER, NODECEN
INTEGER, ALLOCATABLE, DIMENSION(:):: PROP   !VECTOR PARA DETERMINAR LAS PROPIEDADES DE LOS ELEMENTOS.
INTEGER, ALLOCATABLE, DIMENSION(:,:):: MIE  !CONECTIVIDADES.
INTEGER, ALLOCATABLE, DIMENSION(:):: UX, UY !GRADOS DE LIBERTAD DESPLAZAMIENTOS.
INTEGER, ALLOCATABLE, DIMENSION(:,:):: NODEX, NODEY !GRADOS DE LIBERTAD RESTRINGIDOS EN CADA DIRECCIÓN.
INTEGER, ALLOCATABLE, DIMENSION(:,:):: NF   !NODOS CARGADOS
INTEGER, ALLOCATABLE, DIMENSION(:,:):: TPLOAD   !TIPO DE CARGA SOBRE EL NODO. HACE REFERENCIA AL NÚMERO DE CARGA Y SE COMPLEMENTA CON EL VALOR Y LA DIRECCIONALIDAD.
REAL*8, ALLOCATABLE, DIMENSION(:,:):: MATERIAL  !VECTOR CON LA INFORMACIÓN DE LOS MATERIALES A UTILIZAR. POISSON Y MÓDULO DE ELASTICIDAD.
REAL*8, ALLOCATABLE, DIMENSION(:):: BETA    !VELOCIDAD ONDA DE CORTE.
REAL*8, ALLOCATABLE, DIMENSION(:):: NU      !COEFICIENTE DE POISSON.
REAL*8, ALLOCATABLE, DIMENSION(:):: RHO     !DENSIDAD.
INTEGER NT      !NÚMERO DE TIEMPOS PARA EL PULSO DE RICKER.
REAL*8 FC       !FRECUENCIA CARACTERISTICA DEL PULSO DE RICKER
REAL*8 TINI        !CENTRO DEL PULSO DE RICKER.
REAL*8 TTOT       !TIEMPO TOTAL DE LA SEÑAL
REAL*8 FI       !ÁNGULO DE INCIDENCIA DE LA ONDA
INTEGER SUM
INTEGER, ALLOCATABLE, DIMENSION(:):: IDPR
INTEGER, ALLOCATABLE, DIMENSION(:):: U
REAL*8 X1, X2, X3, X4, Y1, Y2, Y3, Y4
REAL*8 LONG, ALT
!
!
INTEGER, ALLOCATABLE, DIMENSION(:,:):: EXPMESH
INTEGER, ALLOCATABLE, DIMENSION(:):: HMEPN

INTEGER, ALLOCATABLE, DIMENSION(:,:):: INCO1, IMPRIME, IMPRIME1
INTEGER, ALLOCATABLE, DIMENSION(:):: POSREP, VECIMP

CHARACTER(15):: NCOMPLE

REAL*8 elapsed_time
INTEGER tclock1, tclock2, clock_rate
call system_clock(tclock1)  ! start wall timer
!
!
OPEN(10,FILE='DatosGenerales.txt')
READ(10,*)
READ(10,*)
READ(10,*)
READ(10,*) NMAT
ALLOCATE(MATERIAL(NMAT,3))
READ(10,*)
DO I=1, NMAT
    READ(10,*) MATERIAL(I,1), MATERIAL(I,2), MATERIAL(I,3)
END DO 
!
READ(10,*)
READ(10,*)
READ(10,*) TONDA
!
READ(10,*)
READ(10,*)
READ(10,*)
READ(10,*) FC, TTOT, TINI, NT, FI
!
CLOSE(10)
!
!
OPEN(10,FILE='gmesh_files/canonquad.msh')
READ(10,*)
READ(10,*)
READ(10,*)
READ(10,*)
READ(10,'(1I10)') NP        !NUMBER OF NODES.
!
ALLOCATE(X(NP), Y(NP), IDN(NP))
!
DO I=1, NP
!
    READ(10,*) IDN(I), X(I), Y(I), JUAN
!
END DO
!
READ(10,*)
READ(10,*)
!
READ(10,'(1I10)') ND        !DATA TO READ.
!
!
!ALLOCATE(TPB(ND))
!
NEL=0
NIMPRIME=0
!TPB=1000
!
!ACÁ VOY A CONTAR LOS ELEMENTOS DE LA FRONTERA SOBRE LOS CUALES SE VA A PONER UN ELEMENTO
!ABSORBENTE. DE PASO SALE EL NÚMERO DE ELEMENTOS DEL PROBLEMA.
!
DO I=1, ND
!
    READ(10,*) J, L, K, M
!
    IF (L==8 .AND. M==3) THEN
        NIMPRIME=NIMPRIME+1
    END IF
!
    IF (L>8) THEN
!
        NEL=NEL+1
!
    END IF
!
END DO
!
CLOSE(10)
!
ALLOCATE(IMPRIME(NIMPRIME,3))
IMPRIME=0
!
OPEN (10, FILE='Coord.txt')
!
DO I=1, NP
    WRITE(10, '(2F11.6)') X(I), Y(I)
END DO
!
CLOSE(10)
!
X=0.0D0
Y=0.0D0
!
OPEN (10, FILE='Coord.txt')
!
DO I=1, NP
    READ(10, '(2F11.6)') X(I), Y(I)
END DO
!
!X=X/10.0D0
!Y=Y/10.0D0
!
CLOSE(10, STATUS='DELETE')
!
LONG=MAXVAL(X)
ALT=MAXVAL(Y)
!
!
!NEL:NUMERO DE ELEMENTOS.
!
OPEN(10,FILE='gmesh_files/canonquad.msh')
READ(10,*)
READ(10,*)
READ(10,*)
READ(10,*)
READ(10,*)
!
DO I=1, NP
!
    READ(10,*)
!
END DO
!
READ(10,*)
READ(10,*)
READ(10,*)
!
ND=ND-NIMPRIME
!
ALLOCATE(BOUNDARY(ND-NEL), NODEIZ(ND-NEL), NODECEN(ND-NEL), &
         NODEDER(ND-NEL), TL(ND-NEL))
!
NODEIZ=0
NODEDER=0
NODECEN=0
!
NGLX=0
NGLY=0
!
!ACÁ YA IDENTIFICO POR COMPLETO LOS ELEMENTOS SOBRE LOS CUALES SE VAN A PONER LAS
!FRONTERAS ABSORBENTES.
!
II=0
JJ=0
!
DO I=1, ND-NEL+NIMPRIME
!
    READ(10,*) J, K, L, M, N, O, P, Q
!
    IF(M==3) THEN
        II=II+1
        IMPRIME(II,1)=O
        IMPRIME(II,2)=P
        IMPRIME(II,3)=Q
    ELSE
        JJ=JJ+1
        NODEIZ(JJ) =O
        NODEDER(JJ)=P
        NODECEN(JJ)=Q
    END IF
!
END DO
!
!
ALLOCATE(IMPRIME1(NIMPRIME,3))
!
IMPRIME1=IMPRIME
IFLAG=1
!
DO I=1, NIMPRIME
!
    IF (IMPRIME1(I,2).NE.0) THEN
        DO WHILE (IFLAG==1)
            CALL BELONGS(IMPRIME1(:,2),NIMPRIME,IMPRIME(I,1),IFLAG)
            IF(IFLAG==1) THEN
                CALL SEARCHPOS(IMPRIME1(:,2),NIMPRIME,IMPRIME(I,1),IPOS)
                IMPRIME1(IPOS,2)=0
            END IF
        END DO
    END IF
    IFLAG=1
!
END DO
!
J=0
K=0
!
DO I=1, NIMPRIME
    IF (IMPRIME1(I,2).NE.0) THEN
        K=K+1
    END IF
END DO
!
ALLOCATE(VECIMP(NIMPRIME*2+K))
VECIMP=0
!
J=1
DO I=1, NIMPRIME
    VECIMP(J)=IMPRIME1(I,1)
    J=J+1
!
    VECIMP(J)=IMPRIME(I,3)
    J=J+1
!
    IF (IMPRIME1(I,2).NE.0) THEN
        VECIMP(J)=IMPRIME1(I,2)
        J=J+1
    END IF
END DO
!
NIMPRIME=NIMPRIME*2+K
!
!
!ACÁ VOY A ENCONTRAR LA MATRIZ INDICADORA DE ECUACIÓN Y LAS PROPIEDADES DE CADA
!ELEMENTO DEL DOMINIO
!
ALLOCATE(TP(NEL), MIE(8,NEL))
!
TP=0
MIE=0
PROP=0
!
DO I=1, NEL
!
    READ(10,*) J,TP(I),K,INCO1(I,2),L, MIE(1,I), MIE(2,I), MIE(3,I), MIE(4,I), &
                                        MIE(5,I), MIE(6,I), MIE(7,I), MIE(8,I)
    INCO1(I,2)=INCO1(I,2)/1000+9
!
END DO
!
!
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
DO I=1, ND-NEL
!
    NX=NODEIZ(I)
    NY=NODEDER(I)
!
    DO J=1, NEL
!
        IF (NX==MIE(1,J) .AND. NY==MIE(2,J)) THEN
!
            INCO1(J,1)=4
            INCO1(J,2)=2
            INCO1(J,3)=3
            EXIT
!
        END IF
!
!
        IF (NX==MIE(2,J) .AND. NY==MIE(3,J)) THEN
!
            INCO1(J,1)=4
            INCO1(J,2)=3
            INCO1(J,3)=4
            EXIT
!
        END IF
!
!
        IF (NX==MIE(3,J) .AND. NY==MIE(4,J)) THEN
!
            INCO1(J,1)=4
            INCO1(J,2)=4
            INCO1(J,3)=1
            EXIT
!
        END IF
!
!
        IF (NX==MIE(4,J) .AND. NY==MIE(1,J)) THEN
!
            INCO1(J,1)=4
            INCO1(J,2)=5
            INCO1(J,3)=2
            EXIT
!
        END IF
!
!
    END DO
!
END DO
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!
!
OPEN(10,FILE='../canon8.inp')
!
WRITE(10, '(1A20)') 'HalfSpace'
WRITE(10, '(3I8, 1F8.3, 8I6)') NP, ND, NMAT+7, TTOT, NT, 2, &
                               8, 16, 5, 1, 0, NIMPRIME
                                !ACÁ ADICIONÉ UNA POSICIÓN MÁS, LA CUAL
                                !ME SIRVE PARA DECIRLE AL PROGRAMA QUE VA A
                                !IMPRIMIR HISTORIAS EN UN NÚMERO DETERMINADO
                                !DE PUNTOS NIMPRIME: NUMERO DE PUNTOS
                                !EN LOS CUALES SE VA A IMPRIMIR HISTORIAS.
!
DO I=1, NP
!
    WRITE(10, '(4I6, 2F10.4)') I, 2, 0, 0, X(I), Y(I)
!
END DO
!
!
WRITE(10, '(3I4, 5F10.2, 1I4)') 1, 5, 0, MATERIAL(1,1), MATERIAL(1,2), &
                                MATERIAL(1,3), 0.0D0, 0.0D0
!
!EL SIGUIENTE BLOQUE CORRESPONDE A LOS ELEMENTOS QUE HACEN PARTE DEL INCOMING.
!
WRITE(10, '(3I4, 5F10.2, 1I4)') 2, 5, 1, MATERIAL(2,1), MATERIAL(2,2), &
                                MATERIAL(2,3), 0.0D0, 0.0D0, 3
WRITE(10, '(3I4, 5F10.2, 1I4)') 3, 5, 1, MATERIAL(2,1), MATERIAL(2,2), &
                                MATERIAL(2,3), 0.0D0, 0.0D0, 4
WRITE(10, '(3I4, 5F10.2, 1I4)') 4, 5, 1, MATERIAL(2,1), MATERIAL(2,2), &
                                MATERIAL(2,3), 0.0D0, 0.0D0, 1
WRITE(10, '(3I4, 5F10.2, 1I4)') 5, 5, 1, MATERIAL(2,1), MATERIAL(2,2), &
                                MATERIAL(2,3), 0.0D0, 0.0D0, 2
WRITE(10, '(3I4, 5F10.2, 1I4)') 6, 5, 1, MATERIAL(2,1), MATERIAL(2,2), &
                                MATERIAL(2,3), 0.0D0, 0.0D0, 5
WRITE(10, '(3I4, 5F10.2, 1I4)') 7, 5, 1, MATERIAL(2,1), MATERIAL(2,2), &
                                MATERIAL(2,3), 0.0D0, 0.0D0, 6
WRITE(10, '(3I4, 5F10.2, 1I4)') 8, 5, 1, MATERIAL(2,1), MATERIAL(2,2), &
                                MATERIAL(2,3), 0.0D0, 0.0D0, 7
WRITE(10, '(3I4, 5F10.2, 1I4)') 9, 5, 1, MATERIAL(2,1), MATERIAL(2,2), &
                                MATERIAL(2,3), 0.0D0, 0.0D0, 8
!
DO I=1, NMAT-2
    WRITE(10, '(3I4, 5F10.2, 1I4)') 9+I, 5, 0, MATERIAL(2+I,1), &
                                    MATERIAL(2+I,2),MATERIAL(2+I,3), &
                                    0.0D0, 0.0D0
END DO
!
!1: TIPO DE ONDA, 1: P-WAVE, 2: S-WAVE
!2: TIEMPO TOTAL DE LA SEÑAL
!3: TIEMPO CENTRAL DEL PUSLO
!4: FRECUENCIA CARACTERISTICA DEL PULSO
!5: AMPLITUD DE LA SEÑAL
!6: ÁNGULO DE INCIDENCIA DE LA ONDA
!
WRITE(10, '(1I6, 5F8.4)') TONDA, TTOT, TINI, FC, 1.0D0, FI
!
!
DO I=1, NEL
!

    WRITE(10,'(13I8)') I, INCO1(I,1), 16, INCO1(I,2), 8, MIE(1,I), MIE(2,I), &
                       MIE(3,I), MIE(4,I), MIE(5,I), MIE(6,I), MIE(7,I), MIE(8,I)
!
END DO
!
DO I=1, NEL
!
    IF (MIE(1,I)==11) THEN
        WRITE(10,'(1I7, 4I4, 8I8)') I, INCO1(I,1), 16, 8, 8, MIE(1,I), MIE(2,I), &
                           MIE(3,I), MIE(4,I), MIE(5,I), MIE(6,I), &
                           MIE(7,I), MIE(8,I)
    ELSE
        IF (MIE(3,I)==8) THEN
            WRITE(10,'(1I7, 4I4, 8I8)') I, INCO1(I,1), 16, 6, 8, MIE(1,I), &
                   MIE(2,I), MIE(3,I), MIE(4,I), MIE(5,I), MIE(6,I), &
                   MIE(7,I), MIE(8,I)
        ELSE
            WRITE(10,'(1I7, 4I4, 8I8)') I, INCO1(I,1), 16, INCO1(I,2), 8, &
                   MIE(1,I), MIE(2,I), &
                   MIE(3,I), MIE(4,I), MIE(5,I), MIE(6,I), &
                   MIE(7,I), MIE(8,I)
        END IF
    END IF
END DO
DO I=1, ND-NEL
!
    WRITE(10,'(8I8)') I+NEL, 7, 6, 1, 3, NODEDER(I), NODECEN(I), NODEIZ(I)
!
END DO
!
DO I=1, NIMPRIME
    WRITE(10,'(1I16)') VECIMP(I)
END DO
!
!
call system_clock(tclock2, clock_rate)
elapsed_time = float(tclock2 - tclock1) / float(clock_rate)
print 11, elapsed_time
11 format("Elapsed time = ",f12.4, " seconds")

END PROGRAM MALLAS
























