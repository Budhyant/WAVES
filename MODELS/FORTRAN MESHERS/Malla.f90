PROGRAM MALLA

IMPLICIT NONE

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!							SCALAR INTEGERS

INTEGER I, J, K, L, M, N, O, P, Q, R, S, T, U, V

INTEGER NMAT							!NUMBER OF MATERIALS
INTEGER NMAT1							!NUMBER OF MATERIALS
INTEGER TONDA 							!WAPE TYPE
INTEGER NT								!NUMBER OF TIMES
INTEGER NP								!TOTAL NUMBER OF POINTS
INTEGER ND								!TOTAL NUMBER OF ELEMENTS CREATED BY GMSH
										!THIS IS NOT THE NUMBER OF THE ELEMENTS OF
										!THE MESH TO BE USED IN DAMIAN-PAR
INTEGER NBH								!NUMBER OF ABOSRBING BOUNDARY ELEMENTS
										!IN THE HALF-SPACE
INTEGER NBB								!NUMBER OF ABOSRBING BOUNDARY ELEMENTS
										!IN THE BOTTOM STRATA
INTEGER NBM								!NUMBER OF ABOSRBING BOUNDARY ELEMENTS
										!IN THE MIDDLE STRATA
INTEGER NBT								!NUMBER OF ABOSRBING BOUNDARY ELEMENTS
										!IN THE TOP STRATA
INTEGER NIMP							!NUMBER OF LINE ELEMENTS WHERE THE RESULTS WILL
										!BE PRINTED OUT
INTEGER NTR								!NUMBER OF SIX NODES ELEMENTS
INTEGER NREC							!NUMBER OF NINE NODES ELEMENTS

INTEGER NEL								!NUMBER OF ELEMENTS. THE ABSORBING BOUNDARIES ARE
										!NOT INCLUIDED
INTEGER IFLAG, IPOS

INTEGER N1, N2, N3						!AUXILIAR INTEGERS

INTEGER NELINCO							!ELEMENTS IN THE INCOMING

INTEGER NPINCO							!TOTAL POINTS OF THE INCOMING ELEMENTS

INTEGER NTH								!NODOS A USAR EN PARALELIZACIÓN
INTEGER FOTO							!CADA CUANTOS DT IMPRIME UNA FOTO EN PARAVIEW
INTEGER tclock1, tclock2, clock_rate

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!							SCALAR FLOATS

REAL*8 FC								!CHARACTERISTICS FREQUENCY OF THE RICKER PULSE
REAL*8 TF								!TOTAL TIME OF THE SIGNAL
REAL*8 TC								!CENTER OF THE RICKER PULSE
REAL*8 FI								!INCIDENCE ANGLE OF THE PLANE WAVE
REAL*8 elapsed_time
REAL*8 JUAN, CARLOS						!AUXILIAR VARIABLES

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!							CHARACTERS

CHARACTER(15):: FILENAME
CHARACTER(50):: TEXTPLANTILLA

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!							FLOATS ARRAYS

REAL*8, ALLOCATABLE, DIMENSION(:,:):: MATERIAL		!ARRAY OF MATERIAL'S PROPERTIES
REAL*8, ALLOCATABLE, DIMENSION(:):: X, Y			!X AND Y COORDINATES OF THE NODES

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!							INTEGER ARRAYS

INTEGER, ALLOCATABLE, DIMENSION(:,:):: ENBH			!CONNECTIVITY OF THE ABSORBING
													!ELEMENTS IN THE HALF-SPACE

INTEGER, ALLOCATABLE, DIMENSION(:,:):: ENBB			!CONNECTIVITY OF THE ABSORBING
													!ELEMENTS IN THE BOTTOM STRATA

INTEGER, ALLOCATABLE, DIMENSION(:,:):: ENBM			!CONNECTIVITY OF THE ABSORBING
													!ELEMENTS IN THE MIDDLE STRATA

INTEGER, ALLOCATABLE, DIMENSION(:,:):: ENBT			!CONNECTIVITY OF THE ABSORBING
													!ELEMENTS IN THE TOP STRATA

INTEGER, ALLOCATABLE, DIMENSION(:,:):: ENTR			!CONNECTIVITY OF THE SIX NODES
													!ELEMENTS

INTEGER, ALLOCATABLE, DIMENSION(:,:):: ENREC		!CONNECTIVITY OF THE NINE NODES
													!ELEMENTS

INTEGER, ALLOCATABLE, DIMENSION(:,:):: ENIMP		!NUMBER OF ELEMENTS, WHERE THE
													!RESPONSE IT'S GOING TO PRINTED
													!OUT

INTEGER, ALLOCATABLE, DIMENSION(:,:):: AUXARRAY		!AUXILIAR ARRAY

INTEGER, ALLOCATABLE, DIMENSION(:):: VECIMP			!VECTOR CONTAINING THE NODES WHERE
													!THE RESPONSE IT'S GOING TO BE PRINTED
													!OUT.

INTEGER, ALLOCATABLE, DIMENSION(:):: MAT			!PROPERTIES RELATED TO THE PHYSICAL
													!SURFACES
													
INTEGER, ALLOCATABLE, DIMENSION(:,:):: MIE			!MATRIX INDICATOR EQUATION

INTEGER, ALLOCATABLE, DIMENSION(:):: INCO			!PROPERTIE RELATED TO THE INCOMING
													!SURFACE INSIDE THE DOMAIN

INTEGER, ALLOCATABLE, DIMENSION(:,:):: NDRMMOD		!ARRAY WITH CONNECTIVITY OF THE
													!ELEMENTS CONTAINING WHERE THE
													!IT'S GOING TO BE USED TO CALCULATE
													!THE INCOMING FIELD WITH AN OUTSIDE
													!FILE

INTEGER, ALLOCATABLE, DIMENSION(:):: V1, V2			!AUXILIARY ARRAYS TO PRINTOUT THE
													!NODES ON THE INCOMING ELEMENTS.
		
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!							BEGINS THE CALCULATIONS

call system_clock(tclock1)  ! start wall timer

!EN ESTE PRIMER BLOQUE LEEMOS LOS DATOS DE ENTRADA, EN EL CUAL SE TIENE LO SIGUIENTE:
!NOMBRE DEL ARCHIVO DE GMSH
!NÚMERO DE MATERIALES A EMPLEAR EN EL MODELO
!LOS MATERIALES, EN EL SIGUIENTE ORDE: VELOCIDAD P, VELOCIDAD S, DENSIDAD
!INFORMACIÓN DEL TIPO DE ONDA A EMPLEAR EN EL MODELO
!DATOS PARA EL ANÁLISIS EN EL DOMINIO DEL TIEMPO
!CADA CUANTOS DELTAS DE TIEMPO IMPRIME UNA FOTO PARA PARAVIEW

OPEN(10,FILE='Entrada.txt')

READ(10,*) FILENAME
READ(10,*) TEXTPLANTILLA

FILENAME=TRIM(FILENAME)

READ(10,*) NMAT

ALLOCATE(MATERIAL(NMAT,3))
!MATERIAL(#, 1): P-WAVE VELOCITY
!MATERIAL(#, 2): S-WAVE VELOCITY
!MATERIAL(#, 3): DENSITY

READ(10,*)

DO I=1, NMAT
    READ(10,*) MATERIAL(I,1), MATERIAL(I,2), MATERIAL(I,3)
END DO 

READ(10,*)
READ(10,*)
READ(10,*) TONDA
!1: P-WAVE INCIDENT
!2: S-WAVE INCIDENT
!3: DISPLACEMENTS INCLUDED AT A FILE

READ(10,*)
READ(10,*)
READ(10,*)
READ(10,*) FC, TF, TC, NT, FI

READ(10,*)
READ(10,*)
READ(10,*) FOTO

READ(10,*)
READ(10,*)
READ(10,*) NTH

CLOSE(10)

!TERMINÓ EL BLOQUE CON LOS DATOS DE ENTRADA GENERALES


!EN ESTE BLOQUE SE ABRE EL ARCHIVO DE GMSH, Y SE COMIENZA A LEER

OPEN(10,FILE=TRIM(FILENAME)//'.msh')
READ(10,*)
READ(10,*)
READ(10,*)
READ(10,*)
READ(10,'(1I10)') NP        !NUMBER OF NODES.

ALLOCATE(X(NP), Y(NP))

X=0.0D0
Y=0.0D0

DO I=1, NP
	READ(10,*) J, X(I), Y(I), JUAN
END DO

!OJO QUE ESTA PARTE SOLO APLICA CUANDO TENGO AMPLIFICADO EN UN ORDEN DE MAGNITUD EL
!ARCHIVO DE GMSH

X=X/10.0D0
Y=Y/10.0D0

READ(10,*)
READ(10,*)

READ(10,*) ND

NBH=0
NIMP=0
NTR=0
NREC=0

!EN ESTE
DO I=1, ND
	READ(10,*) J, L, K, M
	
	IF (L==8 .AND. M==1) THEN
		NBH=NBH+1
	END IF

	IF (L==8 .AND. M==2) THEN
		NIMP=NIMP+1
	END IF

	IF (L==9) THEN
		NTR=NTR+1
	END IF

	IF (L==10) THEN
		NREC=NREC+1
	END IF

END DO

CLOSE(10)

ALLOCATE(ENBH(NBH, 3), ENIMP(NIMP,3), &
		 ENTR(NTR, 6), ENREC(NREC,9))


OPEN(10,FILE=TRIM(FILENAME)//'.msh')
READ(10,*)
READ(10,*)
READ(10,*)
READ(10,*)
READ(10,*)
!
DO I=1, NP
!
    READ(10,*)
!
END DO
!
READ(10,*)
READ(10,*)
READ(10,*)

ENBH=0
ENTR=0
ENREC=0
ENIMP=0

R=0
S=0
T=0
U=0
V=0

DO I=1, NBH+NIMP

	READ(10,*) J, K, L, M, N, O, P, Q

	IF (K==8) THEN
		
		IF (M==1) THEN
			R=R+1
			ENBH(R,1)= O
			ENBH(R,2)= Q
			ENBH(R,3)= P
		END IF
		
		IF (M==2) THEN
			V=V+1
			ENIMP(V,1)= O
			ENIMP(V,2)= P
			ENIMP(V,3)= Q
		END IF
		
	END IF
	
END DO

ALLOCATE(AUXARRAY(NIMP, 3))

AUXARRAY=ENIMP

DO I=1, NIMP
    IFLAG=1
    IPOS=0
    DO WHILE (IFLAG==1)
        CALL BELONGS(AUXARRAY(:,2),NIMP,ENIMP(I,1),IFLAG)
        IF(IFLAG==1) THEN
            CALL SEARCHPOS(AUXARRAY(:,2),NIMP,ENIMP(I,1),IPOS)
            AUXARRAY(IPOS,2)=0
        END IF
    END DO
END DO

K=0

DO I=1, NIMP
	IF(AUXARRAY(I,2) .NE. 0) THEN
		K=K+1
	END IF
END DO

ALLOCATE(VECIMP(NIMP*2+K))
VECIMP=0

J=1

DO I=1, NIMP
	VECIMP(J)=AUXARRAY(I,1)
	J=J+1
	
	VECIMP(J)=AUXARRAY(I,3)
	J=J+1
	
	IF (AUXARRAY(I,2) .NE. 0) THEN
		VECIMP(J)=AUXARRAY(I,2)
		J=J+1
	END IF
END DO

NIMP=2*NIMP+K

DEALLOCATE(AUXARRAY)
DEALLOCATE(ENIMP)

NEL=NTR+NREC

ALLOCATE(MIE(9, NEL), MAT(NEL))
ALLOCATE(INCO(NEL))

INCO=0
MIE=0
MAT=0

DO I=1, NTR
	
	READ(10,*) J, K, L, MAT(I), N, MIE(1,I), MIE(2,I), MIE(3,I), &
								   MIE(4,I), MIE(5,I), MIE(6,I)

	INCO(I)=6

END DO

DO I=1, NREC
	
	READ(10,*) J, K, L, MAT(I+NTR), N, MIE(1,I+NTR), MIE(2,I+NTR), MIE(3,I+NTR), &
								       MIE(4,I+NTR), MIE(5,I+NTR), MIE(6,I+NTR), &
								   	   MIE(7,I+NTR), MIE(8,I+NTR), MIE(9,I+NTR)

	INCO(I+NTR)=3

END DO

MAT=MAT/1000

CLOSE(10)

DO I=1, NBH

	N1=ENBH(I,1)
	N3=ENBH(I,3)
	
	DO J=1, NEL
	
		IF (N1==MIE(1,J) .AND. N3==MIE(2,J) .AND. MAT(J)==10) THEN
			INCO(J)= 5
			MAT(J) = 2
			EXIT
		END IF
		
		IF (N1==MIE(2,J) .AND. N3==MIE(3,J) .AND. MAT(J)==10) THEN
			INCO(J)= 5
			MAT(J) = 3
			EXIT
		END IF
		
		IF (N1==MIE(3,J) .AND. N3==MIE(4,J) .AND. MAT(J)==10) THEN
			INCO(J)= 5
			MAT(J) = 4
			EXIT
		END IF
		
		IF (N1==MIE(4,J) .AND. N3==MIE(1,J) .AND. MAT(J)==10) THEN
			INCO(J)= 5
			MAT(J) = 5
			EXIT
		END IF
		
	END DO
	
END DO

NELINCO=NBH

ALLOCATE(NDRMMOD(NELINCO, 9))
NDRMMOD=0

L=0
M=0
N=0
O=0

DO I=1, NELINCO

	L=L+1
	N1=ENBH(L,1)
	N3=ENBH(L,3)

    DO J=1, NEL

        IF (N1==MIE(1,J) .AND. N3==MIE(2,J) .AND. INCO(J)==5) THEN
            NDRMMOD(I,:)=MIE(:,J)
            EXIT
        END IF

        IF (N1==MIE(2,J) .AND. N3==MIE(3,J) .AND. INCO(J)==5) THEN
            NDRMMOD(I,:)=MIE(:,J)
            EXIT
        END IF

        IF (N1==MIE(3,J) .AND. N3==MIE(4,J) .AND. INCO(J)==5) THEN
            NDRMMOD(I,:)=MIE(:,J)
            EXIT
        END IF

        IF (N1==MIE(4,J) .AND. N3==MIE(1,J) .AND. INCO(J)==5) THEN
            NDRMMOD(I,:)=MIE(:,J)
            EXIT
        END IF

    END DO

END DO

ALLOCATE(V1(NELINCO*8), V2(NELINCO*8))

V1=0
V2=0

K=0

DO J=1, 8
	DO I=1, NELINCO
		K=K+1
		V1(K)=NDRMMOD(I,J)
	END DO
END DO

DO I=1, NELINCO*8
    IF (V1(I) .NE. 0) THEN
        V2(I)= V1(I)
        V1(I)= 0
        IFLAG= 1
    
        DO WHILE (IFLAG==1)
            CALL BELONGS(V1, NELINCO*8, V2(I), IFLAG)
            IF(IFLAG==1) THEN
                CALL SEARCHPOS(V1, NELINCO*8, V2(I), IPOS)
                V1(IPOS)= 0
            END IF
        END DO
        
    END IF
END DO

K=0
DO I=1, NELINCO*8
    IF (V2(I) .NE. 0) THEN
        K=K+1
    END IF
END DO

DEALLOCATE(V1)

NPINCO=NELINCO+K

ALLOCATE(V1(NPINCO))

V1=0

K=0

DO I=1, NELINCO*8
    IF (V2(I) .NE. 0) THEN
        K=K+1
        V1(K)=V2(I)
    END IF
END DO

DO I=1, NELINCO
    K=K+1
    V1(K)=NDRMMOD(I,9)
END DO

DEALLOCATE(V2, NDRMMOD)


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

FILENAME=TRIM(FILENAME)//'.inp'
OPEN (10, FILE=FILENAME)

TEXTPLANTILLA=trim(TEXTPLANTILLA)
WRITE(10,*) TEXTPLANTILLA

NMAT1= NMAT+9

WRITE(10, '(3I8, 1F8.2, 1I7, 7I6)') NP, NEL+NELINCO, NMAT1, TF, NT, 2, &
                               9, 18, 5, 1, 0, NIMP

!NP: NUMBER OF POINTS.
!NEL+NELINCO: TOTAL NUMBER OF ELEMENTS.
!NMAT: TOTAL NUMBER OF MATERIALS
!TF: TOTAL TIME OF THE INPUT SIGNAL
!NT: TOTAL NUMBER OF DELTA TIME
!2:  DEGREE OF FREEDOMS PER NODE
!9:  MAXIMUN NUMBER OF NODES PER ELEMENT
!18: MAXIMUN DEGREE OF FREEDOMS PER ELEMENT
!5:  MAXIMUM NUMBER OF MATERIAL PROPERTIES IN A PROFILE
!1:  MAXIMUM NUMBER OF INTEGER MAT PROPERTIES IN A PROFILE
!0:  NUMBER OF POINT LOADS
!NIMP: NUMBER OF POINTS WHERE THE RESPONSE IT'S GOING TO BE PRINTED OUT

WRITE(10,'(2I8)') FOTO, NTH

DO I=1, NP

    WRITE(10, '(1I16, 3I6, 2F15.10)') I, 2, 0, 0, X(I), Y(I)

END DO

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!HALF-SPACE ELEMENTS

!FRONTERAS ABSORBENTES EN EL SEMIESPACIO

WRITE(10, '(3I4, 5F10.2, 1I4)') 1, 5, 0, MATERIAL(1,1), MATERIAL(1,2), &
                                MATERIAL(1,3), 0.0D0, 0.0D0

!EL SIGUIENTE BLOQUE CORRESPONDE A LOS ELEMENTOS QUE HACEN PARTE DEL INCOMING
!EN EL HALF-SPACE.

WRITE(10, '(3I4, 5F10.2, 1I4)') 2, 5, 1, MATERIAL(1,1), MATERIAL(1,2), &
                                MATERIAL(1,3), 0.0D0, 0.0D0, 3
WRITE(10, '(3I4, 5F10.2, 1I4)') 3, 5, 1, MATERIAL(1,1), MATERIAL(1,2), &
                                MATERIAL(1,3), 0.0D0, 0.0D0, 4
WRITE(10, '(3I4, 5F10.2, 1I4)') 4, 5, 1, MATERIAL(1,1), MATERIAL(1,2), &
                                MATERIAL(1,3), 0.0D0, 0.0D0, 1
WRITE(10, '(3I4, 5F10.2, 1I4)') 5, 5, 1, MATERIAL(1,1), MATERIAL(1,2), &
                                MATERIAL(1,3), 0.0D0, 0.0D0, 2
WRITE(10, '(3I4, 5F10.2, 1I4)') 6, 5, 1, MATERIAL(1,1), MATERIAL(1,2), &
                                MATERIAL(1,3), 0.0D0, 0.0D0, 5
WRITE(10, '(3I4, 5F10.2, 1I4)') 7, 5, 1, MATERIAL(1,1), MATERIAL(1,2), &
                                MATERIAL(1,3), 0.0D0, 0.0D0, 6
WRITE(10, '(3I4, 5F10.2, 1I4)') 8, 5, 1, MATERIAL(1,1), MATERIAL(1,2), &
                                MATERIAL(1,3), 0.0D0, 0.0D0, 7
WRITE(10, '(3I4, 5F10.2, 1I4)') 9, 5, 1, MATERIAL(1,1), MATERIAL(1,2), &
                                MATERIAL(1,3), 0.0D0, 0.0D0, 8

DO I=1, NMAT
    WRITE(10, '(3I4, 5F10.2, 1I4)') 9+I, 5, 0, MATERIAL(I,1), &
                                    MATERIAL(I,2),MATERIAL(I,3), &
                                    0.0D0, 0.0D0
END DO

!1: TIPO DE ONDA, 1: P-WAVE, 2: S-WAVE, 3: DISPLACEMENT FIELD
!2: TIEMPO TOTAL DE LA SEÑAL
!3: TIEMPO CENTRAL DEL PUSLO
!4: FRECUENCIA CARACTERISTICA DEL PULSO
!5: AMPLITUD DE LA SEÑAL
!6: ÁNGULO DE INCIDENCIA DE LA ONDA

WRITE(10, '(1I6, 5F8.4)') TONDA, TF, TC, FC, 1.0D0, FI

J=0

DO I=1, NTR
	J=J+1
	WRITE(10,'(1I7, 4I4, 6I8)') I, INCO(I), 12, MAT(I), 6, MIE(1,I), MIE(2,I), &
                           MIE(3,I), MIE(4,I), MIE(5,I), MIE(6,I)
END DO

DO I=1, NREC
	J=J+1
	WRITE(10,'(1I7, 4I4, 9I8)') J, INCO(J), 18, MAT(J), 9, MIE(1,J), MIE(2,J), &
                           MIE(3,J), MIE(4,J), MIE(5,J), MIE(6,J), &
                           MIE(7,J), MIE(8,J), MIE(9,J)
END DO

DO I=1, NBH
	J=J+1
	WRITE(10, '(1I7, 4I4, 3I8)') J, 7, 6, 1, 3, &
								 ENBH(I,3), ENBH(I,2), ENBH(I,1)
END DO

DO I=1, NIMP
    WRITE(10,'(1I16)') VECIMP(I)
END DO

CLOSE(10)

call system_clock(tclock2, clock_rate)
elapsed_time = float(tclock2 - tclock1) / float(clock_rate)
print 11, elapsed_time
11 format("Elapsed time = ",f12.4, " seconds")

END PROGRAM MALLA








SUBROUTINE BELONGS(LIST,NDAT,IVAL,IFLAG)

INTEGER NDAT, IVAL, IFLAG, I
DIMENSION LIST(NDAT)

IFLAG=0
DO I=1,NDAT
    IF(IVAL.EQ.LIST(I)) THEN
        IFLAG=1
        EXIT
    END IF
END DO

RETURN

END


SUBROUTINE SEARCHPOS(LIST,NDAT,NVAL,IPOS)

INTEGER NDAT, NVAL, IPOS, I
DIMENSION LIST(NDAT)

DO I=1,NDAT
    IF(LIST(I).EQ.NVAL) THEN
        IPOS=I
        EXIT
    END IF
END DO

RETURN

END



































